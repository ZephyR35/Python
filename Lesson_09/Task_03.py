#Реализовать класс Worker (работник).
#Техническое задание:

#определить атрибуты: name, surname, position (должность), income (доход)
#атрибут income должен быть защищённым и ссылаться на словарь, содержащий элементы: оклад и премия, например, {"wage": wage, "bonus": bonus}
#При создании экземпляра параметры wage, bonus передаются как числа.
#создать класс Position (должность) на базе класса Worker. Это наследование.
#в классе Position реализовать методы получения полного имени сотрудника (get_full_name) и дохода с учётом премии (get_total_income). Подумайте, корректно ли в классе наследнике напрямую обращаться к защищенному атрибуту income. Или нужен getter? Аргументируйте ответ.
#проверить работу примера на реальных данных: создать экземпляры класса Position, передать данные, проверить значения атрибутов, вызвать методы экземпляров.


class Worker():
    def __init__(self,wage,bonus):
        self.name = 'Иван'
        self.surname = 'Иванов'
        self.position = ''
        self._income = {'wage':wage,'bonus':bonus}

class Position(Worker):
    def get_full_name(self):
        print(self.name)
        print(self.surname)

    def get_total_income(self):
        wage = self._income['wage']
        bonus = self._income['bonus']
        print(f'Оклад составляет: {wage}')
        print(f'Премия составляет: {bonus}')

p1= Position(10000,5000)

#так как в ТЗ указано, что атрибут _income должен быть защищенным, а не приватным, я не использовал геттер
#потому что защищенные атрибуты доступны в дочерних классах. Будь он приватным, такой трюк уже не сработает.
